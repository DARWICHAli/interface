
try:
    import streamlit as st
    import cv2
    from PIL import Image
    from detectron2.utils.visualizer import Visualizer
    from detectron2.data import MetadataCatalog
    import matplotlib.pyplot as plt
    import math
    import pandas as pd
    st.set_page_config(
        page_title="Image Captioning",
        page_icon="üìù",
        layout="wide",
        initial_sidebar_state="expanded"
    )
    import csv
    import sys

    sys.path.insert(1, '/Users/julesbangard/Documents/Master SDSC/Master 2/Projet_master')
    import modele as md
    import modele.rephrase as rf

except Exception as ex:
    st.write(f"Modules are missing {ex}")

if 'lang' not in st.session_state:
    reader = csv.reader(open('lang.csv', 'r'), delimiter=",")
    st.session_state.lang = {}
    for row in reader:
        k, v = row
        st.session_state.lang[k] = v

if 'np_lang' not in st.session_state:
    st.session_state.np_lang = []
    for k in st.session_state.lang:
        st.session_state.np_lang.append(k)


@st.cache(allow_output_mutation=True)
def load_captioning_model():
    return md.get_captionning_model()


@st.cache(allow_output_mutation=True)
def load_segmentation_model():
    return md.get_segmentation_model()


seg_model = load_segmentation_model()
cap_model = load_captioning_model()


# color has to be either red, blue, green, orange or violet
def colored_sentece(sentece, colour) -> str:
    return f":{colour}[{sentece}]"


# premier model
def apply_segmentation_model(image, min_boxes, max_boxes):
    boxes, features, proba_cls, instances = md.segment_picture(seg_model, image, MIN_BOXES=min_boxes, MAX_BOXES=max_boxes)
    return boxes, features, proba_cls, instances


def show_boxes(original_image, cv2_image, column, min_boxes, max_boxes):
    boxes, features, proba_cls, instances = apply_segmentation_model(cv2_image, min_boxes, max_boxes)
    pred = instances.to('cpu')
    box_image = Visualizer(original_image, MetadataCatalog.get("vg"), 1)
    box_image = box_image.draw_instance_predictions(instances)
    column.image(box_image.get_image())
    return boxes, features, proba_cls, instances


# second model (a partir des bounding box ?)
def show_caption(model, features, proba_cls, max_detection=50, beam_size=5, max_len=20, out_size=5,place=st):
    ret = md.caption_segmentation(model, features, proba_cls, max_detections=max_detection, beam_size=beam_size, max_len=max_len, out_size=out_size)
    for s, p in ret:
        place.markdown(f"<i><h3>{s}</h3></i>", unsafe_allow_html=True)
    return ret


def show_statistics(place, cap):
    words = cap[0]
    words = words.split()
    words = [word + "_" + str(i) for (i, word) in enumerate(words)]
    words.append("<EOS>")

    probas = [i for i in cap[1] if i != 0]
    probas = list(map(math.exp, probas))[:len(words)]

    di = {"words": words, "probas": probas}
    data = pd.DataFrame(di)
    place.bar_chart(data, x="words", y="probas")


def main():
    st.title("Image captioning application")
    uploaded_image = st.file_uploader("Upload your image", help="Chose an image to caption")
    tab1, tab2, tab3, tab4 = st.tabs(["Parameters", "Segmentation and caption","Statistics on the caption", "Translate"])

    if uploaded_image is not None:
        tab1.write("Parameters of the caption")
        model_choice = tab1.selectbox("Choose the model you want to use", ["Original model (ResNet 101 + M2)",
                                                                           "ResNet 152 + M2_40m",
                                                                           "ResNet 152 + M2_256m",
                                                                           "ResNet 152 + M2_256m SPIDER training"])
        beam_size = tab1.slider('Size of the beam search', 1, 20, 5)
        out_size = tab1.slider('How many caption do you want ?', 1, 5, 1)
        min_boxes = tab1.slider('Minimum numbers of boxes generated by the segmentation', 3, 40, 10)
        max_boxes = tab1.slider('Maximum numbers of boxes generated by the segmentation', min_boxes, 100, min_boxes)
        max_len = tab1.slider('maximum length of the caption', 1, 25,
                            15)  # TODO reformuler les phrase de maniere plus courte plutot que de les couper
        # pr√©taitement sur l'image avant de la pass√©e ?
        col1, col2 = tab2.columns(2)
        col1.subheader("This is the original image")
        original_image = Image.open(uploaded_image)
        img = original_image.save('img.jpg')  # pour pouvoir read l'image avec CV2
        img = cv2.imread("img.jpg")
        col1.image(original_image)

        caption_btn = col1.button("Caption this image !")
        if caption_btn:
            col2.subheader("Image with bounding boxes")
            boxes, features, proba_cls, instances = show_boxes(original_image, img, col2, min_boxes, max_boxes)
            st.session_state.cap = show_caption(model=cap_model, features=features, proba_cls=proba_cls, max_detection=100,
                         beam_size=beam_size, max_len=max_len, out_size=out_size, place=col2)
            tab3.subheader("Probability of confidence for each word of the sentence : ")
            tab3.write("Last token is the end of sentence")
            show_statistics(tab3, st.session_state.cap[0])
        if st.session_state.cap is not None:
            tab4.subheader("How do you want to translate your caption ? ")
            trad = tab4.radio("In the style of a well known person, or in an other language", ('Celebrity/Gender', 'Language'))
            param = ""
            if trad == 'Celebrity/Gender':
                param = tab4.text_input("Name of the gender or the celebrity", value="", max_chars=50)
            else:
                param = tab4.selectbox("In which language do you want to translate the caption ? ",
                             st.session_state.np_lang)
            translate = tab4.button("Translate !")
            if translate & (trad == 'Celebrity/Gender'):
                tab4.write(rf.rephrase_in_celebrity_style(st.session_state.cap[0][0], param))
            elif translate & (trad == 'Language'):
                tab4.write(rf.translate(st.session_state.cap[0][0], st.session_state.lang[param]))



if __name__ == "__main__":
    main()
